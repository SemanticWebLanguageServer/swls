<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Bevy ECS"><title>bevy_ecs - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bevy_ecs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://bevyengine.org/assets/icon.png"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../bevy_ecs/index.html"><img src="https://bevyengine.org/assets/icon.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../bevy_ecs/index.html"><img src="https://bevyengine.org/assets/icon.png" alt="logo"></a><h2><a href="../bevy_ecs/index.html">bevy_<wbr>ecs</a><span class="version">0.14.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#bevy-ecs" title="Bevy ECS">Bevy ECS</a><ul><li><a href="#what-is-bevy-ecs" title="What is Bevy ECS?">What is Bevy ECS?</a></li><li><a href="#ecs" title="ECS">ECS</a></li><li><a href="#concepts" title="Concepts">Concepts</a></li><li><a href="#using-bevy-ecs" title="Using Bevy ECS">Using Bevy ECS</a></li><li><a href="#features" title="Features">Features</a></li></ul></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>bevy_ecs</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/bevy_ecs/lib.rs.html#2-1762">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="bevy-ecs"><a class="doc-anchor" href="#bevy-ecs">§</a>Bevy ECS</h2>
<p><a href="https://github.com/bevyengine/bevy#license"><img src="https://img.shields.io/badge/license-MIT%2FApache-blue.svg" alt="License" /></a>
<a href="https://crates.io/crates/bevy_ecs"><img src="https://img.shields.io/crates/v/bevy_ecs.svg" alt="Crates.io" /></a>
<a href="https://crates.io/crates/bevy_ecs"><img src="https://img.shields.io/crates/d/bevy_ecs.svg" alt="Downloads" /></a>
<a href="https://docs.rs/bevy_ecs/latest/bevy_ecs/"><img src="https://docs.rs/bevy_ecs/badge.svg" alt="Docs" /></a>
<a href="https://discord.gg/bevy"><img src="https://img.shields.io/discord/691052431525675048.svg?label=&amp;logo=discord&amp;logoColor=ffffff&amp;color=7389D8&amp;labelColor=6A7EC2" alt="Discord" /></a></p>
<h3 id="what-is-bevy-ecs"><a class="doc-anchor" href="#what-is-bevy-ecs">§</a>What is Bevy ECS?</h3>
<p>Bevy ECS is an Entity Component System custom-built for the <a href="https://bevyengine.org/">Bevy</a> game engine.
It aims to be simple to use, ergonomic, fast, massively parallel, opinionated, and featureful.
It was created specifically for Bevy’s needs, but it can easily be used as a standalone crate in other projects.</p>
<h3 id="ecs"><a class="doc-anchor" href="#ecs">§</a>ECS</h3>
<p>All app logic in Bevy uses the Entity Component System paradigm, which is often shortened to ECS. ECS is a software pattern that involves breaking your program up into Entities, Components, and Systems. Entities are unique “things” that are assigned groups of Components, which are then processed using Systems.</p>
<p>For example, one entity might have a <code>Position</code> and <code>Velocity</code> component, whereas another entity might have a <code>Position</code> and <code>UI</code> component. You might have a movement system that runs on all entities with a Position and Velocity component.</p>
<p>The ECS pattern encourages clean, decoupled designs by forcing you to break up your app data and logic into its core components. It also helps make your code faster by optimizing memory access patterns and making parallelism easier.</p>
<h3 id="concepts"><a class="doc-anchor" href="#concepts">§</a>Concepts</h3>
<p>Bevy ECS is Bevy’s implementation of the ECS pattern. Unlike other Rust ECS implementations, which often require complex lifetimes, traits, builder patterns, or macros, Bevy ECS uses normal Rust data types for all of these concepts:</p>
<h4 id="components"><a class="doc-anchor" href="#components">§</a>Components</h4>
<p>Components are normal Rust structs. They are data stored in a <code>World</code> and specific instances of Components correlate to Entities.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }</code></pre></div>
<h4 id="worlds"><a class="doc-anchor" href="#worlds">§</a>Worlds</h4>
<p>Entities, Components, and Resources are stored in a <code>World</code>. Worlds, much like <code>std::collections</code>’s <code>HashSet</code> and <code>Vec</code>, expose operations to insert, read, write, and remove the data they store.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::world::World;

<span class="kw">let </span>world = World::default();</code></pre></div>
<h4 id="entities"><a class="doc-anchor" href="#entities">§</a>Entities</h4>
<p>Entities are unique identifiers that correlate to zero or more Components.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }
<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Velocity { x: f32, y: f32 }

<span class="kw">let </span><span class="kw-2">mut </span>world = World::new();

<span class="kw">let </span>entity = world
    .spawn((Position { x: <span class="number">0.0</span>, y: <span class="number">0.0 </span>}, Velocity { x: <span class="number">1.0</span>, y: <span class="number">0.0 </span>}))
    .id();

<span class="kw">let </span>entity_ref = world.entity(entity);
<span class="kw">let </span>position = entity_ref.get::&lt;Position&gt;().unwrap();
<span class="kw">let </span>velocity = entity_ref.get::&lt;Velocity&gt;().unwrap();</code></pre></div>
<h4 id="systems"><a class="doc-anchor" href="#systems">§</a>Systems</h4>
<p>Systems are normal Rust functions. Thanks to the Rust type system, Bevy ECS can use function parameter types to determine what data needs to be sent to the system. It also uses this “data access” information to determine what Systems can run in parallel with each other.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }

<span class="kw">fn </span>print_position(query: Query&lt;(Entity, <span class="kw-2">&amp;</span>Position)&gt;) {
    <span class="kw">for </span>(entity, position) <span class="kw">in </span><span class="kw-2">&amp;</span>query {
        <span class="macro">println!</span>(<span class="string">"Entity {:?} is at position: x {}, y {}"</span>, entity, position.x, position.y);
    }
}</code></pre></div>
<h4 id="resources"><a class="doc-anchor" href="#resources">§</a>Resources</h4>
<p>Apps often require unique resources, such as asset collections, renderers, audio servers, time, etc. Bevy ECS makes this pattern a first class citizen. <code>Resource</code> is a special kind of component that does not belong to any entity. Instead, it is identified uniquely by its type:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Resource, Default)]
</span><span class="kw">struct </span>Time {
    seconds: f32,
}

<span class="kw">let </span><span class="kw-2">mut </span>world = World::new();

world.insert_resource(Time::default());

<span class="kw">let </span>time = world.get_resource::&lt;Time&gt;().unwrap();

<span class="comment">// You can also access resources from Systems
</span><span class="kw">fn </span>print_time(time: Res&lt;Time&gt;) {
    <span class="macro">println!</span>(<span class="string">"{}"</span>, time.seconds);
}</code></pre></div>
<p>The <a href="examples/resources.rs"><code>resources.rs</code></a> example illustrates how to read and write a Counter resource from Systems.</p>
<h4 id="schedules"><a class="doc-anchor" href="#schedules">§</a>Schedules</h4>
<p>Schedules run a set of Systems according to some execution strategy.
Systems can be added to any number of System Sets, which are used to control their scheduling metadata.</p>
<p>The built in “parallel executor” considers dependencies between systems and (by default) run as many of them in parallel as possible. This maximizes performance, while keeping the system execution safe. To control the system ordering, define explicit dependencies between systems and their sets.</p>
<h3 id="using-bevy-ecs"><a class="doc-anchor" href="#using-bevy-ecs">§</a>Using Bevy ECS</h3>
<p>Bevy ECS should feel very natural for those familiar with Rust syntax:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }
<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Velocity { x: f32, y: f32 }

<span class="comment">// This system moves each entity with a Position and Velocity component
</span><span class="kw">fn </span>movement(<span class="kw-2">mut </span>query: Query&lt;(<span class="kw-2">&amp;mut </span>Position, <span class="kw-2">&amp;</span>Velocity)&gt;) {
    <span class="kw">for </span>(<span class="kw-2">mut </span>position, velocity) <span class="kw">in </span><span class="kw-2">&amp;mut </span>query {
        position.x += velocity.x;
        position.y += velocity.y;
    }
}

<span class="kw">fn </span>main() {
    <span class="comment">// Create a new empty World to hold our Entities and Components
    </span><span class="kw">let </span><span class="kw-2">mut </span>world = World::new();

    <span class="comment">// Spawn an entity with Position and Velocity components
    </span>world.spawn((
        Position { x: <span class="number">0.0</span>, y: <span class="number">0.0 </span>},
        Velocity { x: <span class="number">1.0</span>, y: <span class="number">0.0 </span>},
    ));

    <span class="comment">// Create a new Schedule, which defines an execution strategy for Systems
    </span><span class="kw">let </span><span class="kw-2">mut </span>schedule = Schedule::default();

    <span class="comment">// Add our system to the schedule
    </span>schedule.add_systems(movement);

    <span class="comment">// Run the schedule once. If your app has a "loop", you would run this once per loop
    </span>schedule.run(<span class="kw-2">&amp;mut </span>world);
}</code></pre></div>
<h3 id="features"><a class="doc-anchor" href="#features">§</a>Features</h3><h4 id="query-filters"><a class="doc-anchor" href="#query-filters">§</a>Query Filters</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }
<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Player;
<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Alive;

<span class="comment">// Gets the Position component of all Entities with Player component and without the Alive
// component. 
</span><span class="kw">fn </span>system(query: Query&lt;<span class="kw-2">&amp;</span>Position, (With&lt;Player&gt;, Without&lt;Alive&gt;)&gt;) {
    <span class="kw">for </span>position <span class="kw">in </span><span class="kw-2">&amp;</span>query {
    }
}</code></pre></div>
<h4 id="change-detection"><a class="doc-anchor" href="#change-detection">§</a>Change Detection</h4>
<p>Bevy ECS tracks <em>all</em> changes to Components and Resources.</p>
<p>Queries can filter for changed Components:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }
<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>Velocity { x: f32, y: f32 }

<span class="comment">// Gets the Position component of all Entities whose Velocity has changed since the last run of the System
</span><span class="kw">fn </span>system_changed(query: Query&lt;<span class="kw-2">&amp;</span>Position, Changed&lt;Velocity&gt;&gt;) {
    <span class="kw">for </span>position <span class="kw">in </span><span class="kw-2">&amp;</span>query {
    }
}

<span class="comment">// Gets the Position component of all Entities that had a Velocity component added since the last run of the System
</span><span class="kw">fn </span>system_added(query: Query&lt;<span class="kw-2">&amp;</span>Position, Added&lt;Velocity&gt;&gt;) {
    <span class="kw">for </span>position <span class="kw">in </span><span class="kw-2">&amp;</span>query {
    }
}</code></pre></div>
<p>Resources also expose change state:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Resource)]
</span><span class="kw">struct </span>Time(f32);

<span class="comment">// Prints "time changed!" if the Time resource has changed since the last run of the System
</span><span class="kw">fn </span>system(time: Res&lt;Time&gt;) {
    <span class="kw">if </span>time.is_changed() {
        <span class="macro">println!</span>(<span class="string">"time changed!"</span>);
    }
}</code></pre></div>
<p>The <a href="examples/change_detection.rs"><code>change_detection.rs</code></a> example shows how to query only for updated entities and react on changes in resources.</p>
<h4 id="component-storage"><a class="doc-anchor" href="#component-storage">§</a>Component Storage</h4>
<p>Bevy ECS supports multiple component storage types.</p>
<p>Components can be stored in:</p>
<ul>
<li><strong>Tables</strong>: Fast and cache friendly iteration, but slower adding and removing of components. This is the default storage type.</li>
<li><strong>Sparse Sets</strong>: Fast adding and removing of components, but slower iteration.</li>
</ul>
<p>Component storage types are configurable, and they default to table storage if the storage is not manually defined.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Component)]
</span><span class="kw">struct </span>TableStoredComponent;

<span class="attr">#[derive(Component)]
#[component(storage = <span class="string">"SparseSet"</span>)]
</span><span class="kw">struct </span>SparseStoredComponent;</code></pre></div>
<h4 id="component-bundles"><a class="doc-anchor" href="#component-bundles">§</a>Component Bundles</h4>
<p>Define sets of Components that should be added together.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Default, Component)]
</span><span class="kw">struct </span>Player;
<span class="attr">#[derive(Default, Component)]
</span><span class="kw">struct </span>Position { x: f32, y: f32 }
<span class="attr">#[derive(Default, Component)]
</span><span class="kw">struct </span>Velocity { x: f32, y: f32 }

<span class="attr">#[derive(Bundle, Default)]
</span><span class="kw">struct </span>PlayerBundle {
    player: Player,
    position: Position,
    velocity: Velocity,
}

<span class="kw">let </span><span class="kw-2">mut </span>world = World::new();

<span class="comment">// Spawn a new entity and insert the default PlayerBundle
</span>world.spawn(PlayerBundle::default());

<span class="comment">// Bundles play well with Rust's struct update syntax
</span>world.spawn(PlayerBundle {
    position: Position { x: <span class="number">1.0</span>, y: <span class="number">1.0 </span>},
    ..Default::default()
});</code></pre></div>
<h4 id="events"><a class="doc-anchor" href="#events">§</a>Events</h4>
<p>Events offer a communication channel between one or more systems. Events can be sent using the system parameter <code>EventWriter</code> and received with <code>EventReader</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Event)]
</span><span class="kw">struct </span>MyEvent {
    message: String,
}

<span class="kw">fn </span>writer(<span class="kw-2">mut </span>writer: EventWriter&lt;MyEvent&gt;) {
    writer.send(MyEvent {
        message: <span class="string">"hello!"</span>.to_string(),
    });
}

<span class="kw">fn </span>reader(<span class="kw-2">mut </span>reader: EventReader&lt;MyEvent&gt;) {
    <span class="kw">for </span>event <span class="kw">in </span>reader.read() {
    }
}</code></pre></div>
<p>A minimal set up using events can be seen in <a href="examples/events.rs"><code>events.rs</code></a>.</p>
<h4 id="observers"><a class="doc-anchor" href="#observers">§</a>Observers</h4>
<p>Observers are systems that listen for a “trigger” of a specific <code>Event</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Event)]
</span><span class="kw">struct </span>MyEvent {
    message: String
}

<span class="kw">let </span><span class="kw-2">mut </span>world = World::new();

world.observe(|trigger: Trigger&lt;MyEvent&gt;| {
    <span class="macro">println!</span>(<span class="string">"{}"</span>, trigger.event().message);
});

world.flush();

world.trigger(MyEvent {
    message: <span class="string">"hello!"</span>.to_string(),
});</code></pre></div>
<p>These differ from <code>EventReader</code> and <code>EventWriter</code> in that they are “reactive”. Rather than happening at a specific point in a schedule, they happen <em>immediately</em> whenever a trigger happens. Triggers can trigger other triggers, and they all will be evaluated at the same time!</p>
<p>Events can also be triggered to target specific entities:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_ecs::prelude::<span class="kw-2">*</span>;

<span class="attr">#[derive(Event)]
</span><span class="kw">struct </span>Explode;

<span class="kw">let </span><span class="kw-2">mut </span>world = World::new();
<span class="kw">let </span>entity = world.spawn_empty().id();

world.observe(|trigger: Trigger&lt;Explode&gt;, <span class="kw-2">mut </span>commands: Commands| {
    <span class="macro">println!</span>(<span class="string">"Entity {:?} goes BOOM!"</span>, trigger.entity());
    commands.entity(trigger.entity()).despawn();
});

world.flush();

world.trigger_targets(Explode, entity);</code></pre></div>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.ptr"><code>pub use <a class="mod" href="../bevy_ptr/index.html" title="mod bevy_ptr">bevy_ptr</a> as ptr;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="archetype/index.html" title="mod bevy_ecs::archetype">archetype</a></dt><dd>Types for defining <a href="archetype/struct.Archetype.html" title="struct bevy_ecs::archetype::Archetype"><code>Archetype</code></a>s, collections of entities that have the same set of
components.</dd><dt><a class="mod" href="batching/index.html" title="mod bevy_ecs::batching">batching</a></dt><dd>Types for controlling batching behavior during parallel processing.</dd><dt><a class="mod" href="bundle/index.html" title="mod bevy_ecs::bundle">bundle</a></dt><dd>Types for handling <a href="bundle/trait.Bundle.html" title="trait bevy_ecs::bundle::Bundle"><code>Bundle</code></a>s.</dd><dt><a class="mod" href="change_detection/index.html" title="mod bevy_ecs::change_detection">change_<wbr>detection</a></dt><dd>Types that detect when their internal data mutate.</dd><dt><a class="mod" href="component/index.html" title="mod bevy_ecs::component">component</a></dt><dd>Types for declaring and storing <a href="component/trait.Component.html" title="trait bevy_ecs::component::Component"><code>Component</code></a>s.</dd><dt><a class="mod" href="entity/index.html" title="mod bevy_ecs::entity">entity</a></dt><dd>Entity handling types.</dd><dt><a class="mod" href="event/index.html" title="mod bevy_ecs::event">event</a></dt><dd>Event handling types.</dd><dt><a class="mod" href="identifier/index.html" title="mod bevy_ecs::identifier">identifier</a></dt><dd>A module for the unified <a href="identifier/struct.Identifier.html" title="struct bevy_ecs::identifier::Identifier"><code>Identifier</code></a> ID struct, for use as a representation
of multiple types of IDs in a single, packed type. Allows for describing an <a href="entity/struct.Entity.html" title="struct bevy_ecs::entity::Entity"><code>crate::entity::Entity</code></a>,
or other IDs that can be packed and expressed within a <code>u64</code> sized type.
<a href="identifier/struct.Identifier.html" title="struct bevy_ecs::identifier::Identifier"><code>Identifier</code></a>s cannot be created directly, only able to be converted from other
compatible IDs.</dd><dt><a class="mod" href="intern/index.html" title="mod bevy_ecs::intern">intern</a></dt><dd>Provides types used to statically intern immutable values.</dd><dt><a class="mod" href="label/index.html" title="mod bevy_ecs::label">label</a></dt><dd>Traits used by label implementations</dd><dt><a class="mod" href="observer/index.html" title="mod bevy_ecs::observer">observer</a></dt><dd>Types for creating and storing <a href="observer/struct.Observer.html" title="struct bevy_ecs::observer::Observer"><code>Observer</code></a>s</dd><dt><a class="mod" href="prelude/index.html" title="mod bevy_ecs::prelude">prelude</a></dt><dd>Most commonly used re-exported types.</dd><dt><a class="mod" href="query/index.html" title="mod bevy_ecs::query">query</a></dt><dd>Contains APIs for retrieving component data from the world.</dd><dt><a class="mod" href="removal_detection/index.html" title="mod bevy_ecs::removal_detection">removal_<wbr>detection</a></dt><dd>Alerting events when a component is removed from an entity.</dd><dt><a class="mod" href="schedule/index.html" title="mod bevy_ecs::schedule">schedule</a></dt><dd>Contains APIs for ordering systems and executing them on a <a href="world/struct.World.html" title="struct bevy_ecs::world::World"><code>World</code></a></dd><dt><a class="mod" href="storage/index.html" title="mod bevy_ecs::storage">storage</a></dt><dd>Storage layouts for ECS data.</dd><dt><a class="mod" href="system/index.html" title="mod bevy_ecs::system">system</a></dt><dd>Tools for controlling behavior in an ECS application.</dd><dt><a class="mod" href="world/index.html" title="mod bevy_ecs::world">world</a></dt><dd>Defines the <a href="world/struct.World.html" title="struct bevy_ecs::world::World"><code>World</code></a> and APIs for accessing it directly.</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.define_label.html" title="macro bevy_ecs::define_label">define_<wbr>label</a></dt><dd>Macro to define a new label trait</dd></dl><script type="text/json" id="notable-traits-data">{"Map<I, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/adapters/map/struct.Map.html\" title=\"struct core::iter::adapters::map::Map\">Map</a>&lt;I, F&gt;</code></h3><pre><code><div class=\"where\">impl&lt;B, I, F&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/adapters/map/struct.Map.html\" title=\"struct core::iter::adapters::map::Map\">Map</a>&lt;I, F&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>,\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(&lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" title=\"type core::iter::traits::iterator::Iterator::Item\">Item</a>) -&gt; B,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = B;</div>","Map<Self, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/adapters/map/struct.Map.html\" title=\"struct core::iter::adapters::map::Map\">Map</a>&lt;I, F&gt;</code></h3><pre><code><div class=\"where\">impl&lt;B, I, F&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/adapters/map/struct.Map.html\" title=\"struct core::iter::adapters::map::Map\">Map</a>&lt;I, F&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>,\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(&lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" title=\"type core::iter::traits::iterator::Iterator::Item\">Item</a>) -&gt; B,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = B;</div>","QueryCombinationIter<'_, 's, D, F, K>":"<h3>Notable traits for <code><a class=\"struct\" href=\"query/struct.QueryCombinationIter.html\" title=\"struct bevy_ecs::query::QueryCombinationIter\">QueryCombinationIter</a>&lt;'w, 's, D, F, K&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'w, 's, D: <a class=\"trait\" href=\"query/trait.ReadOnlyQueryData.html\" title=\"trait bevy_ecs::query::ReadOnlyQueryData\">ReadOnlyQueryData</a>, F: <a class=\"trait\" href=\"query/trait.QueryFilter.html\" title=\"trait bevy_ecs::query::QueryFilter\">QueryFilter</a>, const K: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"query/struct.QueryCombinationIter.html\" title=\"struct bevy_ecs::query::QueryCombinationIter\">QueryCombinationIter</a>&lt;'w, 's, D, F, K&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = [D::<a class=\"associatedtype\" href=\"query/trait.WorldQuery.html#associatedtype.Item\" title=\"type bevy_ecs::query::WorldQuery::Item\">Item</a>&lt;'w&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.array.html\">K</a>];</div>","QueryCombinationIter<'_, 's, D::ReadOnly, F, K>":"<h3>Notable traits for <code><a class=\"struct\" href=\"query/struct.QueryCombinationIter.html\" title=\"struct bevy_ecs::query::QueryCombinationIter\">QueryCombinationIter</a>&lt;'w, 's, D, F, K&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'w, 's, D: <a class=\"trait\" href=\"query/trait.ReadOnlyQueryData.html\" title=\"trait bevy_ecs::query::ReadOnlyQueryData\">ReadOnlyQueryData</a>, F: <a class=\"trait\" href=\"query/trait.QueryFilter.html\" title=\"trait bevy_ecs::query::QueryFilter\">QueryFilter</a>, const K: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"query/struct.QueryCombinationIter.html\" title=\"struct bevy_ecs::query::QueryCombinationIter\">QueryCombinationIter</a>&lt;'w, 's, D, F, K&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = [D::<a class=\"associatedtype\" href=\"query/trait.WorldQuery.html#associatedtype.Item\" title=\"type bevy_ecs::query::WorldQuery::Item\">Item</a>&lt;'w&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.array.html\">K</a>];</div>","QueryIter<'_, 's, D, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"query/struct.QueryIter.html\" title=\"struct bevy_ecs::query::QueryIter\">QueryIter</a>&lt;'w, 's, D, F&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'w, 's, D: <a class=\"trait\" href=\"query/trait.QueryData.html\" title=\"trait bevy_ecs::query::QueryData\">QueryData</a>, F: <a class=\"trait\" href=\"query/trait.QueryFilter.html\" title=\"trait bevy_ecs::query::QueryFilter\">QueryFilter</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"query/struct.QueryIter.html\" title=\"struct bevy_ecs::query::QueryIter\">QueryIter</a>&lt;'w, 's, D, F&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = D::<a class=\"associatedtype\" href=\"query/trait.WorldQuery.html#associatedtype.Item\" title=\"type bevy_ecs::query::WorldQuery::Item\">Item</a>&lt;'w&gt;;</div>","QueryIter<'_, 's, D::ReadOnly, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"query/struct.QueryIter.html\" title=\"struct bevy_ecs::query::QueryIter\">QueryIter</a>&lt;'w, 's, D, F&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'w, 's, D: <a class=\"trait\" href=\"query/trait.QueryData.html\" title=\"trait bevy_ecs::query::QueryData\">QueryData</a>, F: <a class=\"trait\" href=\"query/trait.QueryFilter.html\" title=\"trait bevy_ecs::query::QueryFilter\">QueryFilter</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"query/struct.QueryIter.html\" title=\"struct bevy_ecs::query::QueryIter\">QueryIter</a>&lt;'w, 's, D, F&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = D::<a class=\"associatedtype\" href=\"query/trait.WorldQuery.html#associatedtype.Item\" title=\"type bevy_ecs::query::WorldQuery::Item\">Item</a>&lt;'w&gt;;</div>","QueryIter<'w, 's, D::ReadOnly, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"query/struct.QueryIter.html\" title=\"struct bevy_ecs::query::QueryIter\">QueryIter</a>&lt;'w, 's, D, F&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'w, 's, D: <a class=\"trait\" href=\"query/trait.QueryData.html\" title=\"trait bevy_ecs::query::QueryData\">QueryData</a>, F: <a class=\"trait\" href=\"query/trait.QueryFilter.html\" title=\"trait bevy_ecs::query::QueryFilter\">QueryFilter</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"query/struct.QueryIter.html\" title=\"struct bevy_ecs::query::QueryIter\">QueryIter</a>&lt;'w, 's, D, F&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = D::<a class=\"associatedtype\" href=\"query/trait.WorldQuery.html#associatedtype.Item\" title=\"type bevy_ecs::query::WorldQuery::Item\">Item</a>&lt;'w&gt;;</div>","QueryManyIter<'_, 's, D, F, EntityList::IntoIter>":"<h3>Notable traits for <code><a class=\"struct\" href=\"query/struct.QueryManyIter.html\" title=\"struct bevy_ecs::query::QueryManyIter\">QueryManyIter</a>&lt;'w, 's, D, F, I&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'w, 's, D: <a class=\"trait\" href=\"query/trait.ReadOnlyQueryData.html\" title=\"trait bevy_ecs::query::ReadOnlyQueryData\">ReadOnlyQueryData</a>, F: <a class=\"trait\" href=\"query/trait.QueryFilter.html\" title=\"trait bevy_ecs::query::QueryFilter\">QueryFilter</a>, I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"query/struct.QueryManyIter.html\" title=\"struct bevy_ecs::query::QueryManyIter\">QueryManyIter</a>&lt;'w, 's, D, F, I&gt;<div class=\"where\">where\n    I::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" title=\"type core::iter::traits::iterator::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;<a class=\"struct\" href=\"entity/struct.Entity.html\" title=\"struct bevy_ecs::entity::Entity\">Entity</a>&gt;,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = D::<a class=\"associatedtype\" href=\"query/trait.WorldQuery.html#associatedtype.Item\" title=\"type bevy_ecs::query::WorldQuery::Item\">Item</a>&lt;'w&gt;;</div>","QueryManyIter<'_, 's, D::ReadOnly, F, EntityList::IntoIter>":"<h3>Notable traits for <code><a class=\"struct\" href=\"query/struct.QueryManyIter.html\" title=\"struct bevy_ecs::query::QueryManyIter\">QueryManyIter</a>&lt;'w, 's, D, F, I&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'w, 's, D: <a class=\"trait\" href=\"query/trait.ReadOnlyQueryData.html\" title=\"trait bevy_ecs::query::ReadOnlyQueryData\">ReadOnlyQueryData</a>, F: <a class=\"trait\" href=\"query/trait.QueryFilter.html\" title=\"trait bevy_ecs::query::QueryFilter\">QueryFilter</a>, I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"query/struct.QueryManyIter.html\" title=\"struct bevy_ecs::query::QueryManyIter\">QueryManyIter</a>&lt;'w, 's, D, F, I&gt;<div class=\"where\">where\n    I::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" title=\"type core::iter::traits::iterator::Iterator::Item\">Item</a>: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;<a class=\"struct\" href=\"entity/struct.Entity.html\" title=\"struct bevy_ecs::entity::Entity\">Entity</a>&gt;,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.88.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = D::<a class=\"associatedtype\" href=\"query/trait.WorldQuery.html#associatedtype.Item\" title=\"type bevy_ecs::query::WorldQuery::Item\">Item</a>&lt;'w&gt;;</div>","Vec<InternedSystemSet>":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.88.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.u8.html\">u8</a>, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.88.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.u8.html\">u8</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,</div></div>"}</script></section></div></main></body></html>